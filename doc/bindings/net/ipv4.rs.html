<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Module List</title>
    <link rel="stylesheet" type="text/css" href="../../../css/lua.css">
</head>
<body>
	<pre><code id="1">use rlua::prelude::*;</code><code id="2">use std::net::Ipv4Addr;</code><code id="3">use crate::bindings::net::ipv6::LuaIpv6;</code><code id="4"></code><code id="5">pub struct LuaIpv4(pub Ipv4Addr);</code><code id="6"></code><code id="7">impl LuaUserData for LuaIpv4 {</code><code id="8">    fn add_methods&lt;&#x27;lua, M: LuaUserDataMethods&lt;&#x27;lua, Self&gt;&gt;(methods: &amp;mut M) {</code><code id="9">        methods.add_method(&quot;octets&quot;, |_, this: &amp;LuaIpv4, _: ()| {</code><code id="10">            Ok(this.0.octets().to_vec())</code><code id="11">        });</code><code id="12">        methods.add_method(&quot;is_unspecified&quot;, |_, this: &amp;LuaIpv4, _: ()| {</code><code id="13">            Ok(this.0.is_unspecified())</code><code id="14">        });</code><code id="15">        methods.add_method(&quot;is_loopback&quot;, |_, this: &amp;LuaIpv4, _: ()| {</code><code id="16">            Ok(this.0.is_loopback())</code><code id="17">        });</code><code id="18">        methods.add_method(&quot;is_private&quot;, |_, this: &amp;LuaIpv4, _: ()| {</code><code id="19">            Ok(this.0.is_private())</code><code id="20">        });</code><code id="21">        methods.add_method(&quot;is_link_local&quot;, |_, this: &amp;LuaIpv4, _: ()| {</code><code id="22">            Ok(this.0.is_link_local())</code><code id="23">        });</code><code id="24">        methods.add_method(&quot;is_multicast&quot;, |_, this: &amp;LuaIpv4, _: ()| {</code><code id="25">            Ok(this.0.is_multicast())</code><code id="26">        });</code><code id="27">        methods.add_method(&quot;is_broadcast&quot;, |_, this: &amp;LuaIpv4, _: ()| {</code><code id="28">            Ok(this.0.is_broadcast())</code><code id="29">        });</code><code id="30">        methods.add_method(&quot;is_documentation&quot;, |_, this: &amp;LuaIpv4, _: ()| {</code><code id="31">            Ok(this.0.is_documentation())</code><code id="32">        });</code><code id="33">        methods.add_method(&quot;to_ipv6_compatible&quot;, |_, this: &amp;LuaIpv4, _: ()| {</code><code id="34">            Ok(LuaIpv6(this.0.to_ipv6_compatible()))</code><code id="35">        });</code><code id="36">        methods.add_method(&quot;to_ipv6_mapped&quot;, |_, this: &amp;LuaIpv4, _: ()| {</code><code id="37">            Ok(LuaIpv6(this.0.to_ipv6_mapped()))</code><code id="38">        });</code><code id="39">        methods.add_meta_method(LuaMetaMethod::ToString, |_, this, _: ()| {</code><code id="40">            Ok(this.0.to_string())</code><code id="41">        });</code><code id="42">    }</code><code id="43">}</code><code id="44"></code><code id="45">pub fn init(lua: &amp;Lua) -&gt; crate::Result&lt;()&gt; {</code><code id="46">    let module = lua.create_table()?;</code><code id="47"></code><code id="48">    module.set(&quot;new&quot;, lua.create_function( |_, ip: String| {</code><code id="49">        ip.parse().map(LuaIpv4).map_err(LuaError::external)</code><code id="50">    })? )?;</code><code id="51"></code><code id="52">    module.set(&quot;from_table&quot;, lua.create_function( |_, ip: Vec&lt;u8&gt;| {</code><code id="53">        if ip.len() != 4 {</code><code id="54">            return Ok(None);</code><code id="55">        }</code><code id="56">        let (a, b, c, d) = (</code><code id="57">            ip.get(0).unwrap_or(&amp;0),</code><code id="58">            ip.get(1).unwrap_or(&amp;0),</code><code id="59">            ip.get(2).unwrap_or(&amp;0),</code><code id="60">            ip.get(3).unwrap_or(&amp;0));</code><code id="61"></code><code id="62">        Ok(Some(LuaIpv4(Ipv4Addr::new(*a, *b, *c, *d))))</code><code id="63">    })? )?;</code><code id="64"></code><code id="65">    lua.globals().set(&quot;ipv4&quot;, module)?;</code><code id="66"></code><code id="67">    Ok(())</code><code id="68">}</code></pre>
</body>
</html>
