<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Module List</title>
    <link rel="stylesheet" type="text/css" href="../../../css/lua.css">
</head>
<body>
	<pre><code id="1">use rlua::prelude::*;</code><code id="2">use std::{</code><code id="3">    sync::Arc,</code><code id="4">    env,</code><code id="5">    fs::{self, OpenOptions},</code><code id="6">    io::{self, SeekFrom, prelude::*},</code><code id="7">    path::Path</code><code id="8">};</code><code id="9">use serde_json;</code><code id="10">use rlua_serde;</code><code id="11">use crate::bindings::system::LuaMetadata;</code><code id="12">use regex::Regex;</code><code id="13"></code><code id="14">&#x2F;&#x2F;TODO: Move to having a common interface so IO can share the same binding</code><code id="15">pub struct LuaFile(fs::File);</code><code id="16"></code><code id="17">pub fn fs_open(_: &amp;Lua, (path, mode): (String, Option&lt;String&gt;)) -&gt; Result&lt;LuaFile, LuaError&gt; {</code><code id="18">    let mut option = OpenOptions::new();</code><code id="19">    if let Some(mode) = mode {</code><code id="20">        match mode.as_ref() {</code><code id="21">            &quot;r&quot; =&gt; option.read(true).write(false),</code><code id="22">            &quot;w&quot; =&gt; option.create(true).read(false).write(true),</code><code id="23">            &quot;w+&quot; =&gt; option.create(true).read(true).write(true).truncate(true),</code><code id="24">            &quot;a&quot; =&gt; option.append(true),</code><code id="25">            &quot;rw&quot; | _ =&gt; option.create(true).read(true).write(true),</code><code id="26">        };</code><code id="27">    } else {</code><code id="28">        option.create(true).read(true).write(true);</code><code id="29">    }</code><code id="30"></code><code id="31">    option.open(path)</code><code id="32">        .map(LuaFile)</code><code id="33">        .map_err(LuaError::external)</code><code id="34">}</code><code id="35"></code><code id="36">impl LuaUserData for LuaFile {</code><code id="37">    fn add_methods&lt;&#x27;lua, M: LuaUserDataMethods&lt;&#x27;lua, Self&gt;&gt;(methods: &amp;mut M) {</code><code id="38">        methods.add_method_mut(&quot;read&quot;, |_, this: &amp;mut LuaFile, len: Option&lt;usize&gt;|{</code><code id="39">            let bytes = match len {</code><code id="40">                Some(len) =&gt; {</code><code id="41">                    let mut bytes = vec![0u8; len];</code><code id="42">                    this.0.read(&amp;mut bytes).map_err(LuaError::external)?;</code><code id="43">                    bytes</code><code id="44">                },</code><code id="45">                None =&gt; {</code><code id="46">                    let mut bytes = vec![];</code><code id="47">                    this.0.read_to_end(&amp;mut bytes).map_err(LuaError::external)?;</code><code id="48">                    bytes</code><code id="49">                }</code><code id="50">            };</code><code id="51">            Ok(bytes)</code><code id="52">        });</code><code id="53">        methods.add_method_mut(&quot;read_to_string&quot;, |_, this: &amp;mut LuaFile, _: ()|{</code><code id="54">            let mut data = String::new();</code><code id="55">            this.0.read_to_string(&amp;mut data).map_err(LuaError::external)?;</code><code id="56">            Ok(data)</code><code id="57">        });</code><code id="58">        methods.add_method_mut(&quot;write&quot;, |_, this: &amp;mut LuaFile, bytes: Vec&lt;u8&gt;|{</code><code id="59">            Ok(this.0.write(bytes.as_slice()).map_err(LuaError::external)?)</code><code id="60">        });</code><code id="61">        methods.add_method_mut(&quot;write&quot;, |_, this: &amp;mut LuaFile, str: String|{</code><code id="62">            Ok(this.0.write(str.as_bytes()).map_err(LuaError::external)?)</code><code id="63">        });</code><code id="64">        methods.add_method_mut(&quot;flush&quot;, |_, this: &amp;mut LuaFile, _: ()|{</code><code id="65">            Ok(this.0.flush().map_err(LuaError::external)?)</code><code id="66">        });</code><code id="67">        methods.add_method_mut(&quot;sync_all&quot;, |_, this: &amp;mut LuaFile, _: ()|{</code><code id="68">            Ok(this.0.sync_all().map_err(LuaError::external)?)</code><code id="69">        });</code><code id="70">        methods.add_method_mut(&quot;sync_data&quot;, |_, this: &amp;mut LuaFile, _: ()|{</code><code id="71">            Ok(this.0.sync_data().map_err(LuaError::external)?)</code><code id="72">        });</code><code id="73">        methods.add_method(&quot;metadata&quot;, |_, this: &amp;LuaFile, _: ()| {</code><code id="74">            Ok(LuaMetadata(this.0.metadata().map_err(LuaError::external)?))</code><code id="75">        });</code><code id="76">        methods.add_method_mut(&quot;seek&quot;, |_, this: &amp;mut LuaFile, (pos, size): (Option&lt;String&gt;, Option&lt;usize&gt;)| {</code><code id="77">            let size = size.unwrap_or(0);</code><code id="78"></code><code id="79">            let seekfrom = pos.and_then(|s_pos| {</code><code id="80">                Some(match s_pos.as_ref() {</code><code id="81">                    &quot;start&quot; =&gt; SeekFrom::Start(size as u64),</code><code id="82">                    &quot;end&quot; =&gt; SeekFrom::End(size as i64),</code><code id="83">                    &quot;current&quot; | _ =&gt; SeekFrom::Current(size as i64),</code><code id="84">                })</code><code id="85">            }).unwrap_or(SeekFrom::Current(size as i64));</code><code id="86">            Ok(this.0.seek(seekfrom).map_err(LuaError::external)?)</code><code id="87">        });</code><code id="88"></code><code id="89">    }</code><code id="90">}</code><code id="91"></code><code id="92">pub fn init(lua: &amp;Lua) -&gt; crate::Result&lt;()&gt; {</code><code id="93"></code><code id="94">    let module = lua.create_table()?;</code><code id="95"></code><code id="96">    module.set(&quot;open&quot;, lua.create_function( fs_open)? )?;</code><code id="97"></code><code id="98">    module.set(&quot;canonicalize&quot;, lua.create_function( |lua, path: String| {</code><code id="99">        match fs::canonicalize(path).map_err(|err| LuaError::external(err)) {</code><code id="100">            Ok(i) =&gt; Ok(Some(lua.create_string(&amp;i.to_str().unwrap()).unwrap())),</code><code id="101">            _ =&gt; Ok(None)</code><code id="102">        }</code><code id="103">    })? )?;</code><code id="104"></code><code id="105">    &#x2F;&#x2F;Deprecated for path:create_dir</code><code id="106">    module.set(&quot;create_dir&quot;, lua.create_function( |_, (path, all): (String, Option&lt;bool&gt;)| {</code><code id="107">        let result = match all {</code><code id="108">            Some(true) =&gt; fs::create_dir_all(path),</code><code id="109">            _ =&gt; fs::create_dir(path)</code><code id="110">        };</code><code id="111">        Ok(result.is_ok())</code><code id="112">    })? )?;</code><code id="113"></code><code id="114">    &#x2F;&#x2F;Deprecated for path:read_dir</code><code id="115">    module.set(&quot;entries&quot;, lua.create_function( |lua, path: String| {</code><code id="116">        match fs::read_dir(path) {</code><code id="117">            Ok(iter) =&gt; {</code><code id="118">                let mut arc_iter = Arc::new(Some(iter));</code><code id="119">                let f = move |_, _: ()| {</code><code id="120">                    let result = match Arc::get_mut(&amp;mut arc_iter).expect(&quot;entries iterator is mutably borrowed&quot;) {</code><code id="121">                        Some(iter) =&gt; match iter.next() {</code><code id="122">                            Some(Ok(entry)) =&gt; Some(entry.file_name().into_string().unwrap()),</code><code id="123">                            _ =&gt; None</code><code id="124">                        },</code><code id="125">                        None =&gt; None</code><code id="126">                    };</code><code id="127">                    if result.is_none() { *Arc::get_mut(&amp;mut arc_iter).unwrap() = None; }</code><code id="128">                    Ok(result)</code><code id="129">                };</code><code id="130">                Ok(lua.create_function_mut(f)?)</code><code id="131">            }, Err(err) =&gt; Err(LuaError::ExternalError(Arc::new(::failure::Error::from_boxed_compat(Box::new(err)))))</code><code id="132">        }</code><code id="133">    })? )?;</code><code id="134"></code><code id="135">    module.set(&quot;read_dir&quot;, lua.create_function( |lua, path: String| {</code><code id="136">        let mut _list: Vec&lt;String&gt; = Vec::new();</code><code id="137">        for entry in fs::read_dir(path).map_err(|err| LuaError::external(err))? {</code><code id="138">            let entry = entry.map_err(|err| LuaError::external(err))?;</code><code id="139">            _list.push(entry.path().file_name().unwrap_or_default().to_string_lossy().to_string());      </code><code id="140">        }</code><code id="141">        let list_value: serde_json::Value = serde_json::to_value(_list).map_err(|err| LuaError::external(err) )?;</code><code id="142">        let lua_value = rlua_serde::to_value(lua, &amp;list_value)?;</code><code id="143">        Ok(lua_value)</code><code id="144">    })?)?;</code><code id="145"></code><code id="146">    &#x2F;&#x2F;&#x2F;&#x2F;Deprecated for fs:read</code><code id="147">    module.set(&quot;read_file&quot;, lua.create_function( |lua, path: String| {</code><code id="148">        let data = fs::read(path).map_err(|err| LuaError::external(err))?;</code><code id="149">        Ok(lua.create_string(&amp;String::from_utf8_lossy(&amp;data[..]).to_owned().to_string())?)</code><code id="150">    })?)?;</code><code id="151"></code><code id="152">    module.set(&quot;chdir&quot;, lua.create_function(|_, path: String| {</code><code id="153">        env::set_current_dir(path).map_err(LuaError::external)</code><code id="154">    })?)?;</code><code id="155"></code><code id="156">    module.set(&quot;current_dir&quot;, lua.create_function(|_, _:()| {</code><code id="157">        env::current_dir().map(|path| path.to_str().map(|s| s.to_string())).map_err(LuaError::external)</code><code id="158">    })?)?;</code><code id="159"></code><code id="160">    &#x2F;&#x2F;Probably deprecate for path:exists</code><code id="161">    module.set(&quot;exists&quot;, lua.create_function( |_, path: String| {</code><code id="162">        Ok(::std::path::Path::new(&amp;path).exists())</code><code id="163">    })?)?;</code><code id="164"></code><code id="165">    &#x2F;&#x2F;Probably deprecate for path:is_file</code><code id="166">    module.set(&quot;is_file&quot;, lua.create_function( |_, path: String| {</code><code id="167">        Ok(::std::path::Path::new(&amp;path).is_file())</code><code id="168">    })?)?;</code><code id="169"></code><code id="170">    &#x2F;&#x2F;Probably deprecate for path:is_dir</code><code id="171">    module.set(&quot;is_dir&quot;, lua.create_function( |_, path: String| {</code><code id="172">        Ok(::std::path::Path::new(&amp;path).is_dir())</code><code id="173">    })?)?;</code><code id="174"></code><code id="175">    module.set(&quot;symlink&quot;, lua.create_function( |_, (src_path, symlink_dest): (String, String)| {</code><code id="176">        create_symlink(src_path, symlink_dest).map_err(LuaError::external)</code><code id="177">    })?)?;</code><code id="178"></code><code id="179">    &#x2F;&#x2F;Probably deprecate for path:remove</code><code id="180">    module.set(&quot;remove_dir&quot;, lua.create_function( |_, (path, all): (String, Option&lt;bool&gt;)| {</code><code id="181">        match all {</code><code id="182">            Some(true) =&gt; fs::remove_dir_all(&amp;path).map_err(LuaError::external),</code><code id="183">            _ =&gt; fs::remove_dir(&amp;path).map_err(LuaError::external)</code><code id="184">        }</code><code id="185">    })?)?;</code><code id="186"></code><code id="187">    &#x2F;&#x2F;TODO: Rename to something suitable other than touch</code><code id="188">    &#x2F;&#x2F;Probably deprecate for path:create_file</code><code id="189">    module.set(&quot;touch&quot;, lua.create_function( |_, path: String| {</code><code id="190">        fs::OpenOptions::new()</code><code id="191">            .write(true)</code><code id="192">            .create(true)</code><code id="193">            .open(&amp;path)</code><code id="194">            .map(|_| ())</code><code id="195">            .map_err(LuaError::external)</code><code id="196">    })?)?;</code><code id="197"></code><code id="198">	module.set(&quot;copy_file&quot;, lua.create_function(|_, (src, dest): (String, String)| {</code><code id="199">		copy_file(src, dest)</code><code id="200">	})?)?;</code><code id="201"></code><code id="202">	&#x2F;&#x2F; This binding has a known side effect that this doesn&#x27;t copy .git directory</code><code id="203">	module.set(&quot;copy_dir&quot;, lua.create_function(|_, (src, dest): (String, String)| {</code><code id="204">		recursive_copy(src, dest).map_err(LuaError::external) </code><code id="205">	})?)?; </code><code id="206"></code><code id="207">    &#x2F;&#x2F;Deprecated for fs:metadata</code><code id="208">    module.set(&quot;metadata&quot;, lua.create_function( |lua, path: String| {</code><code id="209">        match fs::metadata(path) {</code><code id="210">            Ok(md) =&gt; {</code><code id="211">                let table = lua.create_table()?;</code><code id="212"></code><code id="213">                table.set(&quot;type&quot;, {</code><code id="214">                    let file_type = md.file_type();</code><code id="215">                    if file_type.is_file() { &quot;file&quot; }</code><code id="216">                    else if file_type.is_dir() { &quot;directory&quot; }</code><code id="217">                    else { unreachable!() }</code><code id="218">                })?;</code><code id="219"></code><code id="220">                table.set(&quot;size&quot;, md.len())?;</code><code id="221"></code><code id="222">                &#x2F;&#x2F; TODO: Unix permissions when in Unix</code><code id="223">                table.set(&quot;readonly&quot;, md.permissions().readonly())?;</code><code id="224"></code><code id="225">                table.set(&quot;created&quot;, md.created().map(|time| time.duration_since(::std::time::SystemTime::UNIX_EPOCH).map(|s| s.as_secs()).unwrap_or(0)).ok())?;</code><code id="226">                table.set(&quot;accessed&quot;, md.accessed().map(|time| time.duration_since(::std::time::SystemTime::UNIX_EPOCH).map(|s| s.as_secs()).unwrap_or(0)).ok())?;</code><code id="227">                table.set(&quot;modified&quot;, md.modified().map(|time| time.duration_since(::std::time::SystemTime::UNIX_EPOCH).map(|s| s.as_secs()).unwrap_or(0)).ok())?;</code><code id="228">                Ok(Some(table))</code><code id="229">            },</code><code id="230">            _ =&gt; Ok(None)</code><code id="231">        }</code><code id="232">    })? )?;</code><code id="233"></code><code id="234">    lua.globals().set(&quot;fs&quot;, module)?;</code><code id="235"></code><code id="236">    Ok(())</code><code id="237">}</code><code id="238"></code><code id="239">&#x2F;&#x2F;TODO: Have it set to use either &#96;syslink_file&#96; or &#96;syslink_dir&#96; depending on if the endpoint is a file or directory in the &#96;src_path&#96;</code><code id="240">&#x2F;&#x2F;      Probably move functions into path binding.</code><code id="241">#[cfg(target_family = &quot;windows&quot;)]</code><code id="242">fn create_symlink(src_path: String, dest: String) -&gt; std::io::Result&lt;()&gt; {</code><code id="243">    use std::os::windows::fs::symlink_file;</code><code id="244">    symlink_file(src_path, dest)</code><code id="245">}</code><code id="246">#[cfg(target_family = &quot;unix&quot;)]</code><code id="247">fn create_symlink(src_path: String, dest: String) -&gt; std::io::Result&lt;()&gt; {</code><code id="248">    use std::os::unix::fs::symlink;</code><code id="249">    symlink(src_path, dest)</code><code id="250">}</code><code id="251"></code><code id="252">fn copy_file&lt;S: AsRef&lt;Path&gt;, D: AsRef&lt;Path&gt;&gt;(src: S, dest: D) -&gt; LuaResult&lt;()&gt; {</code><code id="253">	let mut dest = dest.as_ref().to_path_buf();</code><code id="254">    if dest.is_dir() {</code><code id="255">		let file_name = src.as_ref()</code><code id="256">            .file_name()</code><code id="257">            .map(|s| s.to_string_lossy().to_string())</code><code id="258">            .ok_or(LuaError::external(io::Error::from(io::ErrorKind::InvalidInput)))?;</code><code id="259">		dest.push(file_name);</code><code id="260">    };</code><code id="261">    fs::copy(src, dest).map(|_| ())</code><code id="262">        .map_err(LuaError::external)</code><code id="263">}</code><code id="264"></code><code id="265">fn recursive_copy&lt;A: AsRef&lt;Path&gt;, B: AsRef&lt;Path&gt;&gt;(src: A, dest: B) -&gt; io::Result&lt;()&gt; {</code><code id="266">    let path = src.as_ref();</code><code id="267">    if !src.as_ref().exists() {</code><code id="268">       return Err(io::Error::from(io::ErrorKind::NotFound));</code><code id="269">    }</code><code id="270">    if !dest.as_ref().exists() {</code><code id="271">        fs::create_dir(&amp;dest)?;</code><code id="272">    }</code><code id="273">    for entry in path.read_dir()? {</code><code id="274">        let src = entry.map(|e| e.path())?;</code><code id="275">        let src_name = match src.file_name().map(|s| s.to_string_lossy().to_string()) {</code><code id="276">            Some(s) =&gt; s,</code><code id="277">            None =&gt; return Err(io::Error::from(io::ErrorKind::InvalidData))</code><code id="278">        }; </code><code id="279">		let re = Regex::new(r&quot;^\.git&quot;).unwrap();</code><code id="280">		&#x2F;&#x2F; don&#x27;t copy .git directory</code><code id="281">		if re.is_match(&amp;src_name) { </code><code id="282">			continue;</code><code id="283">		}</code><code id="284">        let dest = dest.as_ref().join(src_name); </code><code id="285">        if src.is_file() {</code><code id="286">            fs::copy(src, &amp;dest)?;</code><code id="287">        } </code><code id="288">		else {</code><code id="289">            fs::create_dir_all(&amp;dest)?;</code><code id="290">            recursive_copy(src, &amp;dest)?;</code><code id="291">        }</code><code id="292">    }</code><code id="293">    Ok(())</code><code id="294">}</code><code id="295"></code><code id="296">#[cfg(test)]</code><code id="297">mod tests {</code><code id="298">    use super::*;</code><code id="299"></code><code id="300">    #[test]</code><code id="301">    fn lua_fs () {</code><code id="302">        let lua = Lua::new();</code><code id="303">        init(&amp;lua).unwrap();</code><code id="304"></code><code id="305">        lua.exec::&lt;_, ()&gt;(r#&quot;</code><code id="306">            for entry in fs.entries(&quot;.&#x2F;&quot;) do</code><code id="307">                local md = fs.metadata(entry)</code><code id="308">                print(md.type .. &quot;: &quot; .. entry)</code><code id="309">            end</code><code id="310"></code><code id="311">            assert(fs.canonicalize(&quot;.&quot;), &quot;expected path&quot;)</code><code id="312">            assert(fs.canonicalize(&quot;&#x2F;no&#x2F;such&#x2F;path&#x2F;here&quot;) == nil, &quot;expected nil&quot;)</code><code id="313">        &quot;#, None).unwrap();</code><code id="314">    }</code><code id="315">}</code><code id="316"></code></pre>
</body>
</html>
