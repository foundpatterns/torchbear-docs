<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Module List</title>
    <link rel="stylesheet" type="text/css" href="../../../css/lua.css">
</head>
<body>
	<pre><code id="1">use rlua::prelude::*;</code><code id="2">use std::{</code><code id="3">    mem,</code><code id="4">    collections::HashMap,</code><code id="5">    io::{BufReader, prelude::*},</code><code id="6">    process::{</code><code id="7">        Command,</code><code id="8">        Child,</code><code id="9">        ChildStdout,</code><code id="10">        ChildStdin,</code><code id="11">        ChildStderr,</code><code id="12">        ExitStatus,</code><code id="13">        Stdio,</code><code id="14">        Output</code><code id="15">    }</code><code id="16">};</code><code id="17">use crate::error::Error;</code><code id="18"></code><code id="19">pub struct LuaCommand(Command);</code><code id="20">pub struct LuaChild {</code><code id="21">    child: Child,</code><code id="22">    stdin: ChildStdin,</code><code id="23">    stdout: BufReader&lt;ChildStdout&gt;,</code><code id="24">    stderr: BufReader&lt;ChildStderr&gt;</code><code id="25">}</code><code id="26">pub struct LuaOutput(Output);</code><code id="27">pub struct LuaExitStatus(ExitStatus);</code><code id="28"></code><code id="29">impl LuaUserData for LuaCommand {</code><code id="30">    fn add_methods&lt;&#x27;lua, M: LuaUserDataMethods&lt;&#x27;lua, Self&gt;&gt;(methods: &amp;mut M) {</code><code id="31"></code><code id="32">        fn stdio_type(stdtype: Option&lt;&amp;String&gt;) -&gt; Stdio {</code><code id="33">            match stdtype.map(|s| s.as_str()) {</code><code id="34">                Some(&quot;inherit&quot;) =&gt; Stdio::inherit(),</code><code id="35">                Some(&quot;null&quot;) =&gt; Stdio::null(),</code><code id="36">                Some(&quot;piped&quot;) | _ =&gt; Stdio::piped(),</code><code id="37">            }</code><code id="38">        }</code><code id="39"></code><code id="40">        methods.add_method_mut(&quot;arg&quot;, |_, this: &amp;mut LuaCommand, arg: String|{</code><code id="41">            this.0.arg(arg);</code><code id="42">            Ok(())</code><code id="43">        });</code><code id="44">        methods.add_method_mut(&quot;args&quot;, |_, this: &amp;mut LuaCommand, args: Vec&lt;String&gt;|{</code><code id="45">            this.0.args(args);</code><code id="46">            Ok(())</code><code id="47">        });</code><code id="48">        methods.add_method_mut(&quot;env&quot;, |_, this: &amp;mut LuaCommand, (k, v): (String, String)|{</code><code id="49">            this.0.env(k, v);</code><code id="50">            Ok(())</code><code id="51">        });</code><code id="52">        methods.add_method_mut(&quot;envs&quot;, |_, this: &amp;mut LuaCommand, env: HashMap&lt;String, String&gt;|{</code><code id="53">            this.0.envs(env);</code><code id="54">            Ok(())</code><code id="55">        });</code><code id="56">        methods.add_method_mut(&quot;env_clear&quot;, |_, this: &amp;mut LuaCommand, key: Option&lt;String&gt;|{</code><code id="57">            match key {</code><code id="58">                Some(key) =&gt; this.0.env_remove(key),</code><code id="59">                None =&gt; this.0.env_clear()</code><code id="60">            };</code><code id="61">            Ok(())</code><code id="62">        });</code><code id="63">        methods.add_method_mut(&quot;directory&quot;, |_, this: &amp;mut LuaCommand, dir: String|{</code><code id="64">            this.0.current_dir(dir);</code><code id="65">            Ok(())</code><code id="66">        });</code><code id="67">        methods.add_method_mut(&quot;spawn&quot;, |_, this: &amp;mut LuaCommand, args: Option&lt;HashMap&lt;String, String&gt;&gt;|{</code><code id="68">            if let Some(args) = args {</code><code id="69">                this.0.stdin(stdio_type(args.get(&quot;stdin&quot;)))</code><code id="70">                    .stdout(stdio_type(args.get(&quot;stdout&quot;)))</code><code id="71">                    .stderr(stdio_type(args.get(&quot;stderr&quot;)));</code><code id="72">            } else {</code><code id="73">                this.0.stdin(Stdio::piped())</code><code id="74">                    .stdout(Stdio::piped())</code><code id="75">                    .stderr(Stdio::piped());</code><code id="76">            }</code><code id="77"></code><code id="78">            let mut child = this.0.spawn().map_err(LuaError::external)?;</code><code id="79">            let stdout = mem::replace(&amp;mut child.stdout, None).map(BufReader::new).ok_or(LuaError::external(Error::InternalError))?;</code><code id="80">            let stderr = mem::replace(&amp;mut child.stderr, None).map(BufReader::new).ok_or(LuaError::external(Error::InternalError))?;</code><code id="81">            let stdin = mem::replace(&amp;mut child.stdin, None).ok_or(LuaError::external(Error::InternalError))?;</code><code id="82">            </code><code id="83">            Ok(LuaChild {</code><code id="84">                child: child,</code><code id="85">                stdin: stdin,</code><code id="86">                stdout: stdout,</code><code id="87">                stderr: stderr</code><code id="88">            })</code><code id="89"></code><code id="90">        });</code><code id="91">        methods.add_method_mut(&quot;exec&quot;, |_, this: &amp;mut LuaCommand, _: ()|{</code><code id="92">            this.0.output().map(LuaOutput).map_err(LuaError::external)</code><code id="93">        });</code><code id="94">    }</code><code id="95">}</code><code id="96"></code><code id="97">&#x2F;&#x2F;TODO: Have stdout and stderr share a common binding. Maybe by splitting the method into stdin, and have stdout&#x2F;stderr share the same interface since they both implement &#96;Read&#96; trait</code><code id="98">impl LuaUserData for LuaChild {</code><code id="99">    fn add_methods&lt;&#x27;lua, M: LuaUserDataMethods&lt;&#x27;lua, Self&gt;&gt;(methods: &amp;mut M) {</code><code id="100">        methods.add_method_mut(&quot;kill&quot;, |_, this: &amp;mut LuaChild, _: ()|{</code><code id="101">            this.child.kill().map_err(LuaError::external)</code><code id="102">        });</code><code id="103">        methods.add_method_mut(&quot;id&quot;, |_, this: &amp;mut LuaChild, _: ()|{</code><code id="104">            Ok(this.child.id())</code><code id="105">        });</code><code id="106">        methods.add_method_mut(&quot;wait&quot;, |_, this: &amp;mut LuaChild, _: ()|{</code><code id="107">            this.child.wait().map(LuaExitStatus).map_err(LuaError::external)</code><code id="108">        });</code><code id="109">        methods.add_method_mut(&quot;write&quot;, |_, this: &amp;mut LuaChild, bytes: Vec&lt;u8&gt;|{</code><code id="110">            this.stdin.write(bytes.as_slice()).map_err(LuaError::external)</code><code id="111">        });</code><code id="112">        methods.add_method_mut(&quot;write&quot;, |_, this: &amp;mut LuaChild, data: String|{</code><code id="113">            this.stdin.write(data.as_bytes()).map_err(LuaError::external)</code><code id="114">        });</code><code id="115">        methods.add_method_mut(&quot;flush&quot;, |_, this: &amp;mut LuaChild, _: ()| {</code><code id="116">            this.stdin.flush().map_err(LuaError::external)</code><code id="117">        });</code><code id="118">        methods.add_method_mut(&quot;read&quot;, |_, this: &amp;mut LuaChild, len: Option&lt;usize&gt;|{</code><code id="119">            let bytes = match len {</code><code id="120">                Some(len) =&gt; {</code><code id="121">                    let mut bytes = vec![0u8; len];</code><code id="122">                    this.stdout.read(&amp;mut bytes).map_err(LuaError::external)?;</code><code id="123">                    bytes</code><code id="124">                },</code><code id="125">                None =&gt; {</code><code id="126">                    let mut bytes = vec![];</code><code id="127">                    this.stdout.read_to_end(&amp;mut bytes).map_err(LuaError::external)?;</code><code id="128">                    bytes</code><code id="129">                }</code><code id="130">            };</code><code id="131">            Ok(bytes)</code><code id="132">        });</code><code id="133">        methods.add_method_mut(&quot;read_to_string&quot;, |_, this: &amp;mut LuaChild, _:()|{</code><code id="134">            let mut data = String::new();</code><code id="135">            this.stdout.read_to_string(&amp;mut data).map_err(LuaError::external)?;</code><code id="136">            Ok(data)</code><code id="137">        });</code><code id="138">        methods.add_method_mut(&quot;read_line&quot;, |_, this: &amp;mut LuaChild, _: ()|{</code><code id="139">            let mut data = String::new();</code><code id="140">            this.stdout.read_line(&amp;mut data).map_err(LuaError::external)?;</code><code id="141">            Ok(data)</code><code id="142">        });</code><code id="143">        methods.add_method_mut(&quot;read_error&quot;, |_, this: &amp;mut LuaChild, len: Option&lt;usize&gt;|{</code><code id="144">            let bytes = match len {</code><code id="145">                Some(len) =&gt; {</code><code id="146">                    let mut bytes = vec![0u8; len];</code><code id="147">                    this.stderr.read(&amp;mut bytes).map_err(LuaError::external)?;</code><code id="148">                    bytes</code><code id="149">                },</code><code id="150">                None =&gt; {</code><code id="151">                    let mut bytes = vec![];</code><code id="152">                    this.stderr.read_to_end(&amp;mut bytes).map_err(LuaError::external)?;</code><code id="153">                    bytes</code><code id="154">                }</code><code id="155">            };</code><code id="156">            Ok(bytes)</code><code id="157">        });</code><code id="158">        methods.add_method_mut(&quot;read_error_to_string&quot;, |_, this: &amp;mut LuaChild, _:()|{</code><code id="159">            let mut data = String::new();</code><code id="160">            this.stderr.read_to_string(&amp;mut data).map_err(LuaError::external)?;</code><code id="161">            Ok(data)</code><code id="162">        });</code><code id="163">        methods.add_method_mut(&quot;read_error_line&quot;, |_, this: &amp;mut LuaChild, _: ()|{</code><code id="164">            let mut data = String::new();</code><code id="165">            this.stderr.read_line(&amp;mut data).map_err(LuaError::external)?;</code><code id="166">            Ok(data)</code><code id="167">        });</code><code id="168">    }</code><code id="169">}</code><code id="170"></code><code id="171">impl LuaUserData for LuaOutput {</code><code id="172">    fn add_methods&lt;&#x27;lua, M: LuaUserDataMethods&lt;&#x27;lua, Self&gt;&gt;(methods: &amp;mut M) {</code><code id="173">        methods.add_method(&quot;status&quot;, |_, this: &amp;LuaOutput, _: ()|{</code><code id="174">            Ok(LuaExitStatus(this.0.status))</code><code id="175">        });</code><code id="176">        methods.add_method_mut(&quot;stdout&quot;, |_, this: &amp;mut LuaOutput, _: ()|{</code><code id="177">            String::from_utf8(this.0.stdout.clone()).map_err(LuaError::external)</code><code id="178">        });</code><code id="179">        methods.add_method_mut(&quot;stderr&quot;, |_, this: &amp;mut LuaOutput, _: ()|{</code><code id="180">            String::from_utf8(this.0.stderr.clone()).map_err(LuaError::external)</code><code id="181">        });</code><code id="182">    }</code><code id="183">}</code><code id="184"></code><code id="185">impl LuaUserData for LuaExitStatus {</code><code id="186">    fn add_methods&lt;&#x27;lua, M: LuaUserDataMethods&lt;&#x27;lua, Self&gt;&gt;(methods: &amp;mut M) {</code><code id="187">        methods.add_method(&quot;success&quot;, |_, this: &amp;LuaExitStatus, _: ()|{</code><code id="188">            Ok(this.0.success())</code><code id="189">        });</code><code id="190">        methods.add_method(&quot;code&quot;, |_, this: &amp;LuaExitStatus, _: ()|{</code><code id="191">            Ok(this.0.code())</code><code id="192">        });</code><code id="193">    }</code><code id="194">}</code><code id="195"></code><code id="196">#[allow(unreachable_code)]</code><code id="197">pub fn init(lua: &amp;Lua) -&gt; crate::Result&lt;()&gt; {</code><code id="198">    let module = lua.create_table()?;</code><code id="199"></code><code id="200">    module.set(&quot;new&quot;, lua.create_function( |_, (name, args): (String, Option&lt;Vec&lt;String&gt;&gt;)| {</code><code id="201">        let mut command = Command::new(name);</code><code id="202">        if let Some(args) = args {</code><code id="203">            command.args(args);</code><code id="204">        }</code><code id="205">        Ok(LuaCommand(command))</code><code id="206">    })? )?;</code><code id="207"></code><code id="208">    lua.globals().set(&quot;command&quot;, module)?;</code><code id="209"></code><code id="210">    Ok(())</code><code id="211">}</code><code id="212"></code></pre>
</body>
</html>
