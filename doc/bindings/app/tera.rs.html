<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Module List</title>
    <link rel="stylesheet" type="text/css" href="../../../css/lua.css">
</head>
<body>
	<pre><code id="1">use std::collections::HashMap;</code><code id="2">use std::sync::{Arc, Mutex};</code><code id="3">use rlua::prelude::*;</code><code id="4">use rlua_serde;</code><code id="5">use tera::{Tera, Value as JsonValue, Context as TeraContext};</code><code id="6">use error::Error;</code><code id="7"></code><code id="8">struct LuaTera (Arc&lt;Mutex&lt;Tera&gt;&gt;);</code><code id="9"></code><code id="10">fn get_tera_context_from_table(table: &amp;HashMap&lt;String, LuaValue&gt;) -&gt; Result&lt;TeraContext, LuaError&gt; {</code><code id="11">    let mut context = TeraContext::new();</code><code id="12"></code><code id="13">    for (key, value) in table.iter() {</code><code id="14">        match value {</code><code id="15">            LuaValue::Integer(num) =&gt; context.insert(key, num),</code><code id="16">            LuaValue::Number(num) =&gt; context.insert(key, num),</code><code id="17">            LuaValue::String(string) =&gt; context.insert(key, string.to_str()?),</code><code id="18">            LuaValue::Boolean(boolean) =&gt; context.insert(key, boolean),</code><code id="19">            value @ LuaValue::Table(_) =&gt; {</code><code id="20">                let value: JsonValue = rlua_serde::from_value(value.clone())</code><code id="21">                    .map_err(|err| LuaError::external(err))?;</code><code id="22">                context.insert(key, &amp;value);</code><code id="23">            },</code><code id="24">            LuaValue::Nil =&gt; context.insert(key, &amp;()),</code><code id="25">            value @ _ =&gt; unimplemented!(&quot;Value {:?} is not implemented as a template parameter&quot;, value),</code><code id="26">        }</code><code id="27">    }</code><code id="28"></code><code id="29">    Ok(context)</code><code id="30">}</code><code id="31"></code><code id="32">impl LuaUserData for LuaTera {</code><code id="33">    fn add_methods&lt;&#x27;lua, M: LuaUserDataMethods&lt;&#x27;lua, Self&gt;&gt;(methods: &amp;mut M) {</code><code id="34"></code><code id="35">        methods.add_method(&quot;extend&quot;, |_, this, dir: String| {</code><code id="36">            let mut tera = this.0.try_lock().unwrap();</code><code id="37">            let new_tera = Tera::parse(&amp;dir).map_err(|err| {</code><code id="38">                LuaError::external(format_err!(&quot;{}&quot;, err.to_string()))</code><code id="39">            })?;</code><code id="40">            tera.extend(&amp;new_tera).map_err(|err| {</code><code id="41">                LuaError::external(format_err!(&quot;{}&quot;, err.to_string()))</code><code id="42">            })</code><code id="43">        });</code><code id="44"></code><code id="45">        methods.add_method(&quot;reload&quot;, |_, this, _: ()| {</code><code id="46">            let mut tera = this.0.try_lock().unwrap();</code><code id="47">            tera.full_reload().map_err(|err| {</code><code id="48">                LuaError::external(format_err!(&quot;{}&quot;, err.to_string()))</code><code id="49">            })</code><code id="50">        });</code><code id="51"></code><code id="52">        methods.add_method(&quot;render&quot;, |_, this, (path, params): (String, Option&lt;HashMap&lt;String, LuaValue&gt;&gt;)| {</code><code id="53">            let tera = this.0.try_lock().unwrap();</code><code id="54">            let text = match params {</code><code id="55">                Some(params) =&gt; {</code><code id="56">                    let mut context = get_tera_context_from_table(&amp;params)?;</code><code id="57">                    tera.render(&amp;path, &amp;context)</code><code id="58">                },</code><code id="59">                None =&gt; {</code><code id="60">                    tera.render(&amp;path, &amp;())</code><code id="61">                },</code><code id="62">            }.map_err(|err| {</code><code id="63">                &#x2F;&#x2F; can&#x27;t convert error_chain to failure directly</code><code id="64">                LuaError::external(format_err!(&quot;{}&quot;, err.to_string()))</code><code id="65">            })?;</code><code id="66"></code><code id="67">            Ok(text)</code><code id="68">        });</code><code id="69">    }</code><code id="70">}</code><code id="71"></code><code id="72">pub fn init(lua: &amp;Lua) -&gt; ::Result&lt;()&gt; {</code><code id="73"></code><code id="74">    let new_tera = lua.create_function(move |_, dir: String| {</code><code id="75">        let tera = Tera::new(&amp;dir).unwrap();</code><code id="76">        let arc_mutex = Arc::new(Mutex::new(tera));</code><code id="77">        Ok(LuaTera(arc_mutex))</code><code id="78">    })?;</code><code id="79"></code><code id="80">    let module = lua.create_table()?;</code><code id="81">    module.set(&quot;new&quot;, new_tera)?;</code><code id="82">    lua.globals().set(&quot;tera&quot;, module).map_err(Error::from)?;</code><code id="83"></code><code id="84">    Ok(())</code><code id="85">}</code><code id="86"></code></pre>
</body>
</html>
